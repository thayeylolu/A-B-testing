---
title:  -Ad smart
output:
  pdf_document:
    toc: true
    toc_depth: 2
editor_options: 
  markdown: 
    wrap: 72
---

In this Project, I will work with a **AdSmartABdata data** I found on
Kaggle. I intend to run a case study where A/B testing is applied with
different browsers, for different phone types and accros operating
system platofrms. The primary aim is to compare user interactions to
determine which one statistically improves the navigation experience by
increasing our collecting of your bio information in our smart ad.

The Data Columns :

-   **auction_id:** the unique id of the online user who has been
    presented the BIO. In standard terminologies this is called an
    impression id. The user may see the BIO questionnaire but choose not
    to respond. In that case both the yes and no columns are zero. 

-   **experiment:** which group the user belongs to - control or
    exposed.

    -   **control:** users who have been shown a dummy ad

    -   **exposed:** users who have been shown a creative, an online
        interactive ad, with the SmartAd brand. 

-   **date:** the date in YYYY-MM-DD format

-   **hour:** the hour of the day in HH format.

-   **device_make:** the name of the type of device the user has e.g.
    Samsung

-   **platform_os:** the id of the OS the user has.

-   **browser:** the name of the browser the user uses to see the BIO
    questionnaire.

-   **yes:** 1 if the user chooses the "Yes" radio button for the BIO
    questionnaire.

-   **no:** 1 if the user chooses the "No" radio button for the BIO
    questionnaire.

Import packages for the analysis

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(tools)
library(scales)
library(broom)
library(MASS)
library(rmarkdown)
library(dplyr)
library(MASS)
library(ggrepel)

```

Firstly, I load the data from my local drive .

```{r}
ad.data<- read_csv("ad_data.csv")

```

**Define a Problem statements**

-   Does clicking(answering) the bio questionnaire of the smart ad (yes
    or no = 1) cause an improvement in user engagement?

-   Does engaging(yes = 1) with the bio questionnaire of the smart ad
    result in an improvement in user engagement?

```{r}

# filter on yes and no 
click_bio  <- ad.data|>filter(!(yes == 0 & no == 0))
ignore_bio <- ad.data|>filter((yes == 0 & no == 0))
fill_bio <- ad.data|>filter((yes == 1))

```

```{r}

#clicked bio_questionnaire regardless of response

click_bio$clicked <- 1
ignore_bio$clicked <- 0
fill_bio$clicked <- 1


# drop column 'no' and rename column 'yes'

drop_rename <- function(df){
  names(df)[names(df) == 'yes'] <- 'fil_bio'
  df <- within(df, rm('no'))
  df
}

click_bio <- drop_rename(click_bio)
ignore_bio <- drop_rename(ignore_bio)
fill_bio<- drop_rename(fill_bio)
```

```{r}
# how many users in the experiment?
# how many users in each experiment ignored the experiment?
# how many users clicked the bio in each experiment?
# how many users filled the bios in each experiment?


user_stat <- function(data, data_name){
            data |>
            group_by(experiment)|> 
            summarize(users = n())|>
            mutate(type = data_name)
            }
total_user_stat<- rbind(
      rbind(user_stat(ad.data, 'total'), 
            user_stat(fill_bio, 'fill bio')),
      
      rbind(user_stat(ignore_bio, 'ignores bio'), 
            user_stat(click_bio, 'clicks bio')))

total_user_stat
```

**Visualizing User Statistics**

-   **Users who Click the BIO:**

-   **Users who Fill the BIO**

-   **Users who Ignore the BIO**

-   The representation of click on the radio button (1) and no
    clicks (0) are imbalanced. Users did not click alot. Graphically,
    there are are exposed (treatment) than control.

```{r}

# Calculate y position, placing it in the middle

ggplot(total_user_stat, aes(x = type, y =users, fill = experiment)) +
  geom_col() +
  geom_text_repel(data = total_user_stat, size = 4, mapping = aes(x = type, y =users, label= round(users / nrow(ad.data) * 100, 2)))
```

**Choosing a Blocking Vairable/ feature/regressor**

i am following this principle to select a blocking variable\

-   t is included as a factor in the experiment.

-   It is not of primary interest to the experimenter.

-   It affects the dependent variable.

-   It is unrelated to independent variables in the experiment.

Let's look at the number of unique factors in each of the possible
blocking variables:

```{r}

# possible groups for blocking
paste("Browser:", length(unique(has.answer$browser)))
print('-----------')
paste("Device Make:", length(unique(has.answer$device_make)))
print('-----------')
paste("Platform OS:", length(unique(has.answer$platform_os)))
print('-----------')
paste("Hours:", length(unique(has.answer$hour)))
```

**Observation and Proceeding**

I select the browser as a blocking variable. I will group the browsers
into popular/general browser names. Other potential blocking variable
would be to bin the **hours** or cluster the **device make** into
popular blocks of popular device brand name.

```{r}
unique(has.answer$browser)
```

```{r}
pop_browser <- c('Chrome', 'Facebook', 'Safari', 'Samsung')

ad.data <-ad.data %>%
  mutate(experiment = as.factor(experiment)) %>%
   mutate(gen_browser = case_when(
     str_detect( browser, 'Chrome') ~ "Chrome" , 
     str_detect(browser, 'Facebook') ~ "Facebook" , 
     str_detect( browser, 'Safari') ~ "Safari" , 
     str_detect( browser, 'Samsung') ~ "Samsung" ))
 
```

-   Grouping comparing across confounder `browser` , we observed that
    the level of exposed is consistently higher than control.

```{r}

table(has.answer$yes, has.answer$experiment)

hist_s <-has.answer.1 %>%
  ggplot(aes( x = yes, y = Freq, fill = experiment)) +
  geom_bar(stat = 'identity', position = "dodge")


agg_data.1<-  has.answer %>%
  mutate(experiment = as.factor(experiment)) %>%
  group_by(experiment, device_make, browser,yes) |>
   mutate(props =  n()/nrow(has.answer), cnt = n()) 

hist_s

agg_data.1 %>%
 mutate(yes = as.factor(as.character(yes))) %>%
  ggplot(aes(x = as.factor(browser), y = props, fill = experiment)) +
  geom_bar(position = "dodge", stat = "identity") +
  theme(axis.text.x = element_text(angle = 90)) +
  facet_wrap(~as.factor(yes))


```

**group by popular names**

```{r}
pop_browser <- c('Chrome', 'Facebook', 'Safari', 'Samsung')

grp_browser <-has.answer %>%
  mutate(experiment = as.factor(experiment)) %>%
   mutate(browser_name = case_when(
     str_detect( browser, 'Chrome') ~ "Chrome" , 
     str_detect(browser, 'Facebook') ~ "Facebook" , 
     str_detect( browser, 'Safari') ~ "Safari" , 
     str_detect( browser, 'Samsung') ~ "Samsung" ))
     
grp_browser.1 <-  grp_browser %>%
  mutate(experiment = as.factor(experiment)) %>%
  group_by(experiment, browser_name, yes) |>
   mutate(props =  n()/nrow(has.answer), cnt = n()) 


grp_browser.1 %>%
 mutate(yes = as.factor(as.character(yes))) %>%
  ggplot(aes(x = browser_name, y = props, fill = experiment)) +
  geom_bar(position = "dodge", stat = "identity") +
  theme(axis.text.x = element_text(angle = 90)) +
  facet_wrap(~as.factor(yes))

```

```{r}

hist_s <-has.answer.1 %>%

  ggplot(aes( x = yes, y = Freq, fill = experiment)) +
  geom_bar(stat = 'identity', position = "dodge")


```

```{r}
str(df)
```

```{r}
# drop platform_os, device_make, no

drop_columns <- c( "platform_os", "device_make", "no")
df<- has.answer[,!(names(has.answer) %in% drop_columns)]
```

```{r}
df$yes<- as.factor(as.character(df$yes))

df$experiment <- as.factor(df$experiment)
df$browser <- as.factor(df$browser)
df$days<- difftime(df$date,'2020-07-03' ,units="days")

df$experiment<- fct_relevel(df$experiment, c("control","exposed" ))
#df$browser<- fct_relevel(df$browser,
#                 c("Chrome", "Chrome Mobile WebView","Chrome Mobile",
#                  "Chrome Mobile iOS","Mobile Safari",
#                 "Mobile Safari UI/WKWebView",
#                 "Facebook", "Samsung Internet"))

#df$click_through_rate <- df
```

```{r}
vi.hr.yes<- df
```

Compute the click through rate

```{r}
listde <- c('experiment' , 'browser' ,'yes')
click_df<- df |>dplyr::select(listde)|>
group_by(experiment,browser ) |>
summarize(click_through_rate = round(n()/nrow(df),2))

click_df
```

```{r}
sum(click_df$click_through_rate)
```
