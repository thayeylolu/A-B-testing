---
title:  -Ad smart
output:
  pdf_document:
    toc: true
    toc_depth: 2
editor_options: 
  markdown: 
    wrap: 72
---

In this Project, I will work with a **AdSmartABdata data** I found on
Kaggle. I intend to run a case study where A/B testing is applied with
different browsers, for different phone types and accros operating
system platofrms. The primary aim is to compare user interactions to
determine which one statistically improves the navigation experience by
increasing our collecting of your bio information in our smart ad.

The Data Columns :

-   **auction_id:** the unique id of the online user who has been
    presented the BIO. In standard terminologies this is called an
    impression id. The user may see the BIO questionnaire but choose not
    to respond. In that case both the yes and no columns are zero. 

-   **experiment:** which group the user belongs to - control or
    exposed.

    -   **control:** users who have been shown a dummy ad

    -   **exposed:** users who have been shown a creative, an online
        interactive ad, with the SmartAd brand. 

-   **date:** the date in YYYY-MM-DD format

-   **hour:** the hour of the day in HH format.

-   **device_make:** the name of the type of device the user has e.g.
    Samsung

-   **platform_os:** the id of the OS the user has.

-   **browser:** the name of the browser the user uses to see the BIO
    questionnaire.

-   **yes:** 1 if the user chooses the "Yes" radio button for the BIO
    questionnaire.

-   **no:** 1 if the user chooses the "No" radio button for the BIO
    questionnaire.

Import packages for the analysis

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
library(tools)
library(scales)
library(broom)
library(MASS)
library(rmarkdown)
library(dplyr)
library(MASS)
library(ggrepel)

```

Firstly, I load the data from my local drive .

```{r}
ad.data<- read_csv("ad_data.csv")

```

```{r}

# Calculate y position, placing it in the middle

sad.data <- ad.data|>
          mutate(filled_bio = as.factor(case_when(yes == 1 ~ 1, yes == 0 ~ 0)),
          clicked_bio = as.factor(case_when(yes == 1 | no == 1 ~ 1, yes != 1 | no != 1 ~ 0 )))

```

```{r}
filled_count <- ggplot(sad.data) +
  geom_bar(mapping = aes(x = experiment, fill = filled_bio))
filled_count  


ggplot(sad.data) +
  geom_bar(mapping = aes(x = experiment, fill =clicked_bio))

```

```{r}
# pvalue : 0.05
# chisquare to chekc the signifiacnc eof the varation in the two expe: control and expoure
chisq.test(sad.data$experiment, sad.data$filled_bio, correct=FALSE) 
chisq.test(sad.data$experiment, sad.data$clicked_bio, correct=FALSE)

```

From the Chi-Squared test result, we can conclude that sthen you know
that the difference in the observed sample sizes due to randomness or
chance.

**Define a Problem statements**

-   Does clicking(answering) the bio questionnaire of the smart ad (yes
    or no = 1) cause an improvement in user engagement?

-   Does engaging(yes = 1) with the bio questionnaire of the smart ad
    result in an improvement in user engagement?

```{r}

# filter on yes and no 
click_bio  <- ad.data|>filter(!(yes == 0 & no == 0))
ignore_bio <- ad.data|>filter((yes == 0 & no == 0))
fill_bio <- ad.data|>filter((yes == 1))

```

```{r}

#clicked bio_questionnaire regardless of response

click_bio$clicked <- 1
ignore_bio$clicked <- 0
fill_bio$clicked <- 1


# drop column 'no' and rename column 'yes'

drop_rename <- function(df){
  names(df)[names(df) == 'yes'] <- 'fil_bio'
  df <- within(df, rm('no'))
  df
}

click_bio <- drop_rename(click_bio)
ignore_bio <- drop_rename(ignore_bio)
fill_bio<- drop_rename(fill_bio)
```

```{r}
# how many users in the experiment?
# how many users in each experiment ignored the experiment?
# how many users clicked the bio in each experiment?
# how many users filled the bios in each experiment?


user_stat <- function(data, data_name){
            data |>
            group_by(experiment)|> 
            summarize(users = n())|>
            mutate(type = data_name)
            }
total_user_stat<- rbind(
      rbind(user_stat(ad.data, 'total'), 
            user_stat(fill_bio, 'fill bio')),
      
      rbind(user_stat(ignore_bio, 'ignores bio'), 
            user_stat(click_bio, 'clicks bio')))

total_user_stat
```

**Visualizing User Statistics**

-   **Users who Click the BIO:** About **8.1%** of the total user who
    responded (clicked) to the bio are in the control group. **7.3%** of
    the total user who responded(clicked) to the bio are in the exposed
    group.

-   **Users who Fill the BIO:** About **3.8%** of the total user who
    filled the bio are in the control group. and **3.7%** of the total
    user who filled the bio are in the exposed group.

-   **Users who Ignore the BIO:** About **43.2%** of the total user who
    ignored the bio are in the control group. and **41.5%** of the total
    user who ignored the bio are in the exposed group.

Generally, It is observed that the representation of control and exposed
in the three groups are equally represented but very far from being
termed unbalanced. It still is a good representation.

```{r}

# Calculate y position, placing it in the middle

ggplot(total_user_stat, aes(x = type, y =users, fill = experiment)) +
  geom_col() +
  geom_text_repel(data = total_user_stat, size = 4,
                  mapping = aes(x = type, y =users, 
                  label=paste0(round(users / nrow(ad.data) * 100, 2), "%"))) 
  
```

-   **Does clicking(answering) the bio questionnaire of the smart ad
    (yes or no = 1) cause an improvement in user engagement?**

**Choosing a Blocking Vairable/ feature/regressor**

i am following this principle to select a blocking variable to answer
the two problems:\

-   It is included as a factor in the experiment.

-   It is not of primary interest to the experimenter.

-   It affects the dependent variable.

-   It is unrelated to independent variables in the experiment.

Let's look at the number of unique factors in each of the possible
blocking variables:

```{r}

# possible groups for blocking
paste("Browser:", length(unique(ad.data$browser)))
print('-----------')
paste("Device Make:", length(unique(ad.data$device_make)))
print('-----------')
paste("Platform OS:", length(unique(ad.data$platform_os)))
print('-----------')
paste("Hours:", length(unique(ad.data$hour)))
```

**Observation and Proceeding**

I select the browser as a blocking variable. I will group the browsers
into popular/general browser names. Other potential blocking variable
would be to bin the **hours** or cluster the **device make** into
popular blocks of popular device brand name.

```{r}
unique(ad.data$browser)
```

```{r}

replace_browser <- function (data) {
    data %>%
     mutate(gen_browser = factor(case_when(
        str_detect( browser, 'Android') ~ "Android",
        str_detect( browser, 'Chrome') ~ "Chrome" ,
        str_detect( browser, 'Edge') ~ "Edge",
        str_detect(browser, 'Facebook') ~ "Facebook" , 
        str_detect( browser, 'Firefox') ~ "Firefox",
        str_detect( browser, 'Opera') ~ "Opera",
        str_detect( browser, 'Pinterest') ~ "Pinterest",
        str_detect( browser, 'Puffin') ~ "Puffin",
        str_detect( browser, 'Safari') ~ "Safari" ,
        str_detect( browser, 'Samsung') ~ "Samsung")))
}

click_bio<- replace_browser(click_bio)
ad.data<- replace_browser(ad.data)
fill_bio<- replace_browser(fill_bio)


sad.data<-replace_browser(sad.data)

ggplot(sad.data) +
  geom_bar(aes(x = gen_browser, fill = filled_bio)) 

```

-   Grouping comparing across confounder `browser` , we observed that
    the level of exposed is consistently higher than control.

**group by popular names**

**Compute the click through rate - CTR**

```{r}

# drop where 0 is in 
click_bio_ctr <-  click_bio %>%
  group_by(gen_browser) |>
   mutate(ctr_click =  n()/nrow(ad.data),
          n = n())  

# drop where 0 is in 
fill_bio_ctr <-  fill_bio %>%
  group_by(gen_browser) |>
   mutate(ctr_fill =  n()/nrow(ad.data),
          n = n())  


```

```{r}
#unique(click_bio_ctr$device_make)

```

**Modelling - with OLS :**

```{r}
fill_lm <- lm(ctr_fill ~ gen_browser , data = fill_bio_ctr, )
tidy(fill_lm, conf.int = 0.95) %>% mutate_if(is.numeric, round, 3)

click_lm <- lm(ctr_click ~ gen_browser , data = click_bio_ctr)
tidy(click_lm, conf.int = 0.95) %>% mutate_if(is.numeric, round, 3)
```

```{r}
fill_lm.1 <- lm(ctr_fill ~ gen_browser + hour , data = fill_bio_ctr)
tidy(fill_lm.1, conf.int = 0.95) %>% mutate_if(is.numeric, round, 3)

click_lm.1 <- lm(ctr_click ~ gen_browser + hour , data = click_bio_ctr)
tidy(click_lm.1 , conf.int = 0.95) %>% mutate_if(is.numeric, round, 3)
```
